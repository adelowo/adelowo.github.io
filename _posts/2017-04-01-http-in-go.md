---
layout : post

title : A guide to understanding HTTP in Golang

tags : go

description : The ultimate primer to understand web development in Go

---

I have been [writing/learning Go for the past one month][my_github]. It has been a pleasurable one month and has rekindled the joy i had when i wrote my ___Hello World___ program a little over 2 years ago.

> This blog post is written mainly for new Gophers.

`HTTP` in all it's majesty is made up of requests and responses, no matter what it has been frankensteined to look like. And this is as true at Go's end.

In this post, i would be taking a dive into the standard `net/http` package in other to explain the process of handling requests and returning responses in Go.

### Basics

In languages like PHP and Ruby, we have the concepts of 

- Routers := Receives the request, then dispatch accordingly.

- Controllers := Handles the dispatched HTTP request. A controller can either be an object or a closure.

What about Go ?

In Go, we have only Handlers. Seriously. ___There aren't routers. Everything is an Handler___. And this is only possible because Go is a very opinionated language. Standards are first citizens here.

### So how does Request dispatching and Response transfer work

I talked about standards the other time, all Handlers must have implement a certain interface from the `net/http` standard library

{% highlight go %}

type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}    

{% endhighlight %}

Starting with responses, HTTP in Go relies on the interface described above

All handlers (take that as controllers for a second) ___MUST___ have that signature, i.e a `ServeHTTP` method that must be called to handle the dispatched request. `ResponseWriter`;s job is to write the header, data bytes while the `Request` helps in inspecting the HTTP request.

{% highlight go %}

package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	// associate URLs requested to functions that handle requests
	http.Handle("/hello/lanre", &HelloWorld{"Lanre"})
	http.Handle("/hello/doe", &HelloWorld{"John doe"})
	http.HandleFunc("/", getRequest)

	// start web server
	log.Fatal(http.ListenAndServe(":9999", nil))
}

type HelloWorld struct {
	Name string
}

func (h *HelloWorld) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Hello "+h.Name)
}
    
{% endhighlight %}

> Don't worry about the code. The only thing of interest right now is ___we have a struct (object ?)___ called HelloWorld that has a `ServeHTTP` method which handles both routes (which makes it a controller).


Visiting `localhost:9999/hello/lanre` should spit "Hello Lanre" while `localhost:9999/hello/doe` should give use "Hello John doe".


What about Routers ? What dispatches the request to a controller ?

Routers in Go are called ___Multiplexers___ or ___ServeMuxes___. But regardless of all the overloaded names, they are nothing more than regular handlers. A router is an handler in the fact that it also satisfy the `http.Handler` interface. That is they have a `ServeHTTP` method.
 
 The only difference between a handler and other handlers - middleware, ___controllers___ - is that this handler is some sort of ___a root handler___. As a root handler, you get to attach other handlers to it. Then when it gets run i.e the `ServeHTTP` method is called, it then dispatches the request to a registered handler (controller/middleware) interested in the route.
 
 > This even makes the idea of tinkering with a custom made router cool.

Go's philosophy is batteries included hence the standard library comes with a router that can be utilized in any application. In fact, we already made use of it in the code block above `http.Handle`.

{% highlight go %}

func main() {
	http.Handle("/hello/lanre", &HelloWorld{"Lanre"})
	http.Handle("/hello/doe", &HelloWorld{"John doe"})

	log.Fatal(http.ListenAndServe(":9999", nil))
}
    
{% endhighlight %}

The `http` package comes with the `Handle` and `HandleFunc` functions (which we used above) that helps map routes to handlers.

{% highlight go %}

func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }

func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}

{% endhighlight %}

#### The DefaultServeMux

As you can see from the code block above, the package level functions - `Handle` and `HandleFunc` - are actually ___syntactic sugar___ for attaching routes to a ServeMux - one provided by `net/http`. They actually defer to `DefaultServeMux.Handle`.

It is starting to get a bit fuzzy and it seems like there is lot of ___autowiring___ here <sup>0</sup>. 

{% highlight go %}

type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry
	hosts bool // whether any patterns contain hostnames
}

type muxEntry struct {
	explicit bool
	h        Handler
	pattern  string
}

func NewServeMux() *ServeMux { return new(ServeMux) }

var defaultServeMux ServeMux

var DefaultServeMux = &defaultServeMux

{% endhighlight %}

Basically, what Go does is instantiate a ServeMux for you. `var DefaultServeMux = &defaultServeMux`. Without this, `http.Handle` wouldn't work since we do not have an instance of `DefaultServeMux`.

Let's have a look at a simple but contrived example in other to put together the pieces we have seen so far - handlers (controllers) and errm, handlers (router). I like ancient mythology of gods (Greek and Egyptian), so we would be building something of that sort.

{% highlight go %}

package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type user struct {
	ID        int      `json:"id"`
	Moniker   string   `json:"moniker"`
	Bio       string   `json:"bio"`
	Languages []string `json:"languages`
}

var allUsers []*user

func init() {
	allUsers = []*user{
		{ID: 1, Moniker: "Hades", Bio: "god of the underworld, ruler of the dead and brother to the supreme ruler of the gods, Zeus", Languages: []string{"Greek"}},
		{ID: 2, Moniker: "Horus", Bio: "god of the sun, sky and war", Languages: []string{"Arabic"}},
		{ID: 3, Moniker: "Apollo", Bio: "god of light, music, manly beauty, dance, prophecy, medicine, poetry and almost every other thing. Son of Zeus", Languages: []string{"Greek"}},
		{ID: 4, Moniker: "Artemis", Bio: "goddess of the wilderness and wild animals. Sister to Apollo and daughter of Zeus", Languages: []string{"Greek"}},
	}
}

func main() {

	http.Handle("/users/", users{})

	http.ListenAndServe(":4000", nil)
}

type users struct {
}

func (u users) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)

	j, _ := json.Marshal(allUsers)

	fmt.Fprintf(w, string(j))
}

{% endhighlight %}

You should open up a console 

{% highlight bash %}

$ go run http_test.go #if the above was saved as http_test.go

{% endhighlight %}

After which you make a request to `localhost:4000`, i prefer to use curl. Since we have go running our app already, we need another console window -  I use a tiling terminal (guake mode in terminix)

![only gods are allowed to make use of our app]({{ site.baseurl }}/img/log/long_live_the_gods.png)

> The top left window is what you are looking for

While this is powerful enough to help build web applications, there are issues with the `DefaultServeMux` that must be considered before taking it into production (which our startup sadly enough has done). This considerations have nothing to do with performance but usabilty. While i list them as drawbacks, there are workarounds for them and i show the process of circumverting the workarounds.


- For every new route, a complementary `struct` must be created. This can get pretty frustating and tiring.

> The only exception here is when we decide to reuse the same struct in multiple routes as we did with the `HelloWorld` struct.

The workaround :

Use functions 

{% highlight go %}

	http.HandleFunc("/about", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "You just reached the page of our startup. Thank you for visiting")
	})


{% endhighlight %}

That doesn't compile right ? Handlers are supposed to have a `ServeHTTP` method.

Well yes, but the Go team helped with a little bit of abstraction. Go has a HandlerFunc type that has the same signature as the `ServeHTTP` method. Due to Go's flexibility, types can have methods - even if the type is a string. With this in mind, the `HandlerFunc` [adapts][adapter_pattern] itself with a `ServeHTTP` method in which it just cleverly calls itself i.e the function you passed in.

{% highlight go %}

type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}

{% endhighlight %}

Basically, the `HandleFunc` method just adapts a function into a `http.Handler` interface

{% highlight go %}

// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}


{% endhighlight %}

When you call `HandleFunc`, it justs [adapts][adapter_pattern] the function into a `http.Handler`.


- Lack of parametized routes (`/users/:id`)

___Let's assume we were in a rush to ship an MVP as soon as possible, then we shipped the above code as is___. The code runs fine but on sharing the link to your new company. And all is fine for the next few minutes until someone - who likes mythology - tries to get the details for a god with a specific id. Remember our `json` response has an id field. He then sends an HTTP request to `localhost:9999/users/2`.

![Your startup is broken]({{ site.baseurl }}/img/log/broken-startup.png) 

> Whoops!!! Same response

#### Footnotes

<div id="footnotes"> </div>

[0] This is one of the reasons why i so much love Go. Go is written in Go. I can decide to take a look at packages i am interested in - for instance `net/http` - and figure out how stuff works which is even why i could write this post in the first place

[my_github]: https:github.com/adelowo
[adapter_pattern]: https://wikipedia.org/Adapter