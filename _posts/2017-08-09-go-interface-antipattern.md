---

layout: post
tags: ["Go"]
description: "Abusing Interfaces in Golang"

---

Go as a language interests me a lot and interfaces are one big part of it.
And when I say interfaces, I am talking about the design - satisfied implicitly rather than explicitly -, extremely tied to behaviour,
and the examples that can be found in the standard library.

If you have ever spent some time writing Go code, one thing you would have noticed is the extensive presence of
well defined and small (one method) interfaces.
The universal `io.Reader` and `io.Writer` or the little known `http.RoundTripper` ([I did a blog post on http.RoundTripper][round_tripping]), ....

This is nothing new. It is essentially the `I` in well known SOLID principles by Uncle Bob that
says ___Client should not be forced to depend on methods they do not use___.
And this to some degree I feel adheres to the `L` - SOLID - since the interface is extremely small, it would be
easy to write another implementation that can be substituted without client code figuring out the difference.

The more "go to definition" takes me to the standard library and with the ___not up to par___ refelection standard library <sup>0</sup> <sup>1</sup>,
I have come to appreciate the composition of interfaces.

I like [testing](/tags/#testing) and while writing tests for my Go code, there is a certain thing that freaks the living hell out of me. Mocks.
Having to run an external tool such as mockery in other to generate mocks weirds me out. Not to also mention the fact that the generated mocks
are usually verbose and reduce code coverage <sup>[2](#footnotes2)</sup>. With that said, sometimes I try hand written mocks and this is especially common when
I am trying to simulate the failure of `io.ReadAll()` or `io.Read([]buf)`, just a mock data structure with a `Read` that has `-1, err` as it's
return value.

But in recent times, I have been evaluating code I have written in the past and looking at the absurd amount of flux that goes in this mocks
(autogenerated ones and handwritten) with a bunch of methods that didn't get used in the test but needed to be present so as to fulfill a contract,
After watching [spf13's][spf] 7 common mistakes in Go talk, I found a pattern that could be applied to the situation described above. In his talk, he specifically
mentioned writing functions such that whenever they have to take an interface as a parameter, it has to be the minimum or smallest interface needed for
the function to perform it's operation.In his slides, he had something like :

- Functions should only accept interfaces that require the _methods they need._
- Functions should not accept a broad interface when a narrow one would work.
- Compose broad interfaces made from narrower ones (stdlib already teaches us this one).

> You can think of this as the _Interface segregation principle for functions_. Whatever that means.

So what does this look like in real life ? Luckily he gave an example

{% highlight go %}
// Where File is an interface composed of the following interfaces
// io.Reader, io.ReaderAt, io.Seeker, io.SeekerAt
// io.Writer, io.Closer, io.WriterAt
func ReadIn(f File) {
  b := []byte{}
  n, err := f.Read(b)

}
{% endhighlight %}

He had that converted to

{% highlight go %}
// I am guessing by Reader, he meant io.Reader
func ReadIn(r Reader) {
  b := []byte{}
  n, err := r.Read(b)
  ...
}
{% endhighlight %}

So of what use is this ? This has the benefit of simplifying testing. For something like the `ReadIn` method, we wouldn't have to autogenerate a
100LOC mock (or write a 25 line mock) when all we need is the `Read` method. All that would be needed is

{% highlight go %}
type mockReader struct {}

func (m mockReader) Read(buf []byte) (n int, err error) {
  return -1, errors.New("whoops")
}
{% endhighlight %}

One thing I have always complained about in Go is the reflect standard library, I have always wanted it to be able to dynamically crete a mock in
tests. With this technique, I can get rid of about all of the complaints even though I still want the reflect stdlib to be improved even though some features
are limited to test packages.

:satisfied:

### Footnotes

<div id="footnotes"></div>

[0] I understand there is a saying in the Go community that says __Reflection is never clear__

[1] ___not up to par___ here means I would love somthing like the reflection library found in Java or DotNet where it is possible to create a mock on a real
object. In Java, the reflection library allows you modify the return value of a method. This is extremely useful for tests unlike Go where you have to generate
an entire mock just because you want to test a method call fails. But that is the entire discussion of this blog post anyways :satisfied:

<div id="footnotes2"></div>
[2] I understand code coverage isn't substitutable for software quality but I feel it acts as a pointer.

[round_tripping]: /blog/2017/07/24/roundtripper-go
[spf]: https://youtube.com

